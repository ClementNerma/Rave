/**
 * @file Asynchronous entities
 * @author Cl√©ment Nerma
 * @license Apache-2.0
 */

#[declaration];
#[local_open];

/**
 * Promise type
 * @template T Resolution type
 * @template X Rejection type
 */
class Promise<T, X> {
  /**
   * Create a new promise
   * @param core The promise's core function
   * > @param resolve The resolution callback
   * > > @param data The resolution data
   * > @param reject The rejection callback
   * > > @param data The rejection data
   */
  %new (core: ((resolve: (data: T) => void, reject: (data: X) => void) => void);

  /**
   * Set a resolution callback
   * Will be trigerred immediatly if the promise was already resolved
   * @param resolve The resolution callback
   * > @param data The resolution data
   * @returns This promise
   */
  then (resolve: (data: T) => void) : this;

  /**
   * Set a rejection callback
   * Will be trigerred immediatly if the promise was already rejected
   * @param reject The rejection callback
   * > @param data The rejection data
   * @returns This promise
   */
  catch (reject: (data: X) => void) : this;

  /**
   * Set a final callback
   * Will be trigerred immediatly if the promise was already resolved or rejected
   * @param callback The final callback
   * > @param resolutionData The potential resolution data
   * > @param rejectionData The potential rejection data
   * @returns This promise
   */
  finally (callback: (resolutionData?: T, rejectionData?: X) => void);
}

/**
 * Error-free promises
 * @template T Resolution type
 */
class Promise<T> extends Promise<T, void> {
  /**
   * Make a new promise
   * @param core The promise's core function
   * > @param resolve The resolution callback
   * > > @param data The resolution data
   */
  %new (core: (resolve: (data: T) => void) => void);
}

// ==================== Functions ==================== //

/**
 * Wait for a promise in an asynchronous function
 * @param promise The promise to wait for
 * @returns The promise's resolution data
 */
fn await<T> (promise: Promise<T>) : T;

/**
 * @samedef
 * @throws AwaitRejectionError If the promise fails
 */
fn await<T, X> (promise: Promise<T, X>) : T throws AwaitRejectionError<X>;

/**
 * Wait synchronously for a promise
 * @param promise The promise to wait for
 * @returns The promise's resolution data
 */
fn sync<T> (promise: Promise<T>) : T;

/**
 * @samedef
 * @throws AwaitRejectionError If the promise fails
 */
fn sync<T, X> (promise: Promise<T, X>) : T throws AwaitRejectionError<X>;