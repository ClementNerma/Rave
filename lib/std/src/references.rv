/**
 * @file References handling
 * @author Cl√©ment Nerma
 * @license Apache-2.0
 */

/**
 * Reference
 * @template T Referenced data type
 */
virtual class Ref<T> {
  /**
   * Create a new reference on a value
   * @param value A value
   */
  virtual %new (value: T);

  /**
   * Get the reference's level
   * @returns The reference's level
   */
  level () : u16;

  /**
   * Get the reference's mutability
   * @returns `true` if it is
   */
  mutability () : enum { Mutable, Constant };

  /**
   * Get the value pointed by this reference
   * @returns The value pointed by this reference
   */
  deref () : T;

  /**
   * De-reference recursively
   * @returns The value pointed by the last reference
   * @example new Ref(new Ref(new Ref(2))).deref() == 2
   */
  derefDeep () : T;

  /**
   * Create a reference object from an existing reference
   * @param ref The existing reference
   * @returns A reference object
   */
  static by (ref: *T) : RefCst<T>;

  /**
   * @samedef
   */
  static by (ref: *mut T) : RefMut<T>;
}

/**
 * Constant reference
 * @template T Referenced data type
 */
class RefCst<T> extends Ref<T> {
  super(...);

  /**
   * Create a reference instance from an existing reference
   * @param ref An existing reference
   */
  %new (value: *T);
}

/**
 * Writable reference
 * @template T Referenced data type
 */
class RefMut<T> extends Ref<T> {
  super(...);

  /**
   * Create a reference instance from an existing reference
   * @param ref An existing reference
   */
  %new (value: *mut T);

  /**
   * Write the value pointed by this reference
   * @param value The value to write
   */
  write (value: T);
}

// ==================== Functions ==================== //

/**
 * Create a constant reference on a value
 * @param value A value
 * @returns A constant reference to this value
 */
fn ref<T> (value: T) : *T;

/**
 * Create a mutable reference on a value
 * @param value A value
 * @returns A mutable reference to this value
 */
fn ref_mut<T> (value: T) : *mut T;

/**
 * Check if a reference is a pointer
 * @param value The value to check
 * @returns `true` if it is
 */
fn is_ref<T> (value: T) : false;

/**
 * @samedef
 */
fn is_ref<T> (value: Ref<T>) : true;