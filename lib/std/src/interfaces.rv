/**
 * @file Interfaces of STD
 * @author Cl√©ment Nerma
 * @license Apache-2.0
 */

#[declaration];
#[local_open];

// ==================== Enumerations ==================== //

/**
 * Comparison result
 */
enum Comparison {
  /**
   * Smaller value
   */
  Smaller,

  /**
   * Equal value
   */
  Equal,

  /**
   * Greater value
   */
  Greater
}

// ==================== Interfaces ==================== //

/**
 * Generic type
 */
interface Any {}

/**
 * Object type
 */
interface Object = not Any;

// ==================== Typecasting ==================== //

/**
 * Types convertible to a string
 */
interface Stringifyable {
  /**
   * Convert this instance to a string
   * @param pretty Return a pretty string
   * @returns This instance as a string
   */
  toString (pretty = false) : string;
}

// ==================== Actions ==================== //

/**
 * Clonable types
 */
interface Clonable {
  /**
   * Clone the current instance
   * @returns A clone of current instance
   */
  %clone () : self;
}

/**
 * Serializable types
 */
interface Serializable {
  /**
   * Serialize the current instance
   * @returns The serialized instance
   */
  %serialize () : string;

  /**
   * Unserialize an instance
   * @param serialized The serialized instance
   * @returns The unserialized instance
   * @throws UnserializationError If the provided string is not a valid serialized instance
   */
  static %unserialize (serialized: string) : self throws UnserializationError;
}

// ==================== Comparison ==================== //

/**
 * Types equatable to another one
 * @template T The comparison type
 */
interface EquatableTo<T> {
  /**
   * Check if the current instance is equal to a value
   * @param cmp The comparison value
   * @returns `true` if they are equal
   */
  %equal (cmp: T) : bool;
}

/**
 * Types comparable to another one
 * @template T The comparison type
 */
interface ComparableTo<T> impl EquatableTo<T> {
  /**
   * Compare the current instance to a value
   * @param cmp The comparison value
   * @returns The comparison result
   */
  %compare (cmp: T) : Comparison;
}

/**
 * Types equatable to themselves
 */
type Equatable = EquatableTo<_>;

/**
 * Types comparable to themselves
 */
type Comparable = ComparableTo<_>;

/**
 * Comparator for two types
 * @template T Type of value
 * @template X The type of value to compare
 * > @param a A value of the first type
 * > @param b The value to compare
 * > @returns The comparison result
 */
type ComparatorTo<T ~ ComparableTo<X>, X> = (a: T, b: X) => Comparison;

/**
 * Comparator for a single type
 * @template T Type of value
 * > @param a A value
 * > @param b The value to compare
 * > @returns The comparison result
 */
type Comparator<T ~ Comparable> = (a: T, b: T) => Comparison;
 
// ==================== Arithmetic operations ==================== //

/**
 * Types that can add another type of value
 * @template T The addable type
 * @template R The result type
 */
interface AddableWith<T, R> {
  /**
   * Add a value to the current instance
   * @param value The value to add
   * @returns The resulting value
   */
  %add (value: T) : R;
}

/**
 * Types that can substract another type of value
 * @template T The substractable type
 * @template R The result type
 */
interface SubstractableWith<T, R> {
  /**
   * Substract a value to the current instance
   * @param value The value to substract
   * @returns The resulting value
   */
  %sub (value: T) : R;
}

/**
 * Types that can be multipled by another type of value
 * @template T The type this one is multiplyable by
 * @template R The result type
 */
interface MultiplyableBy<T, R> {
  /**
   * Multiply the current instance by a value
   * @param value The value to multiply by
   * @returns The resulting value
   */
  %mul (value: T) : R;
}

/**
 * Types that can be divided by another type of value
 * @template T The type this one is divisible by
 * @template R The result type
 */
interface DivisibleBy<T, R> {
  /**
   * Divide the current instance by a value
   * @param value The value to divide by
   * @returns The resulting value
   */
  %mul (value: T) : R;
}

/**
 * Types that support modulo with another type of value
 * @template T The type this one is modulable by
 * @template R The result type
 */
interface ModulableBy<T, R> {
  /**
   * Compute the modulo of the current instance by a value
   * @param value The modulo value
   * @returns The resulting value
   */
  %mod (value: T) : R;
}

/**
 * Types that support pow with another type of value
 * @template T The type this one is powable by
 * @template R The result type
 */
interface PowableBy<T, R> {
  /**
   * Compute the pow of the current instance by a value
   * @param value The exponent value
   * @returns The resulting value
   */
  %pow (value: T) : R;
}

/**
 * Types that support basic arithmetic operators with another type of value
 * Operations: addition, substraction, multiplication, division
 * @template T The type to perform the operations by
 * @template R The result type
 */
type ComputableWith<T, R> = AddableWith<T, R>       // Addition
                          & SubstractableWith<T, R> // Substraction
                          & MultiplyableBy<T, R>    // Multiplication
                          & DivisibleBy<T, R>;      // Division

/**
 * Types that support all arithmetic operators with another type of value
 * @template T The type to perform the operations by
 * @template R The result type
 */
type FullyComputableWith<T, R> = ComputableWith<T, R> // Addition, substraction, multiplication, division
                               & ModulableBy<T, R>    // Modulo
                               & PowableBy<T, R>;     // Pow

/**
 * Types can be added to themselves
 */
type Addable = AddableWith<_, _>;

/**
 * Types that can be substracted to themselves
 */
type Substractable = SubstractableWith<_, _>;

/**
 * Types that can be multiplied by themselves
 */
type Multiplyable = MultiplyableBy<_, _>;

/**
 * Types that can be divided by themselves
 */
type Divisible = DivisibleBy<_, _>;

/**
 * Types that can be modulated by themselves
 */
type Modulable = ModulableBy<_, _>;

/**
 * Types that support pow with themselves
 */
type Powable = PowableBy<_, _>;

/**
 * Types that support basic arithmetic operators
 */
type Computable = ComputableWith<_, _>;

/**
 * Types that support all arithmetic operators
 */
type FullyComputable = FullyComputableWith<_, _>;