/**
 * @file Standard Library definition file
 * @author Cl√©ment Nerma
 * @license Apache-2.0
 */

// NOTE: This file declares all entities natively available in SilverNight programs.
//       It is not ran at the beginning of each program but simply acts as a reference for developers and IDEs.

// NOTE: The body of many functions has been written in this file ; it only acts as a reference and may not
//        be implemented exactly the same way during build. Still, the functions' behaviour must remain the same.

// NOTE: Some declarations use a forbidden syntax like declaring as a plain member an instance of the current class.
//       This is allowed as this file only acts as a reference ; native types are self-dependent and so couldn't be
//        described another way.

// NOTE: This file is allowed to declare context-dependant constants without an initialization value.

// NOTE: This file is allowed to use native types or context-dependant constants before their declaration,
//        as some are self-dependants.

// NOTE: Unless otherwise stated, open classes are not inheritable from the outside of this file
//       The mention "NOTE: This class is inheritable" revokes this statement and allows the class to be inherited
//        by end-developer classes
//       Such classes also show their protected fields, as they can be used by their children

// Only module of the STD package
#[module];

// Frontend libraries are declared as extern
#[extern];

// ==================== Basic types ==================== //

/**
 * Generic type
 */
inf Any {}

/**
 * Static reference operator
 * @template DATA The data to get the class from
 * @returns The class 'DATA' is an instance of
 */
proxy! static<DATA: Any>: #pln<Type> {
  getter: flex () : #pln<Type> {
    return typeof!(DATA);
  }
};

// Reference to the current instance's class
type _this = static!<this>;

// Reference to the current class
type _self = static!<self>;

// Reference to the current class' mother
type _super = static!<super>;

// ==================== Typecastable types ====================

/**
 * Types convertible to a boolean
 */
inf BooleanConvertible {
  // Set a typecasting path for booleans
  fn %to<bool> = string || f64 || f32 || u64 || i64 || u32 || i32 || u16 || i16 || u8 || i8;
}

/**
 * Types convertible to an integer
 */
inf IntegerConvertible {
  // Set a typecasting path for signed integers
  fn %to<i64> = f64 || u64 || f32 || i32 || u32 || i16 || u16 || i8 || u8 || bool;

  // Set a typecasting path for unsigned integers
  fn %to<u64> = f64 || i64 || f32 || u32 || i32 || u16 || i16 || u8 || i8 || bool;
}

/**
 * Types convertible to a floating-point number
 */
inf FloatConvertible {
  // Set a typecasting path for floating-point numbers
  fn %to<f64> = f32 || u64 || i64 || u32 || i32 || u16 || i16 || u8 || i8 || bool;
}

/**
 * Types convertible to a number
 */
inf Numerizable {
  // Set a typecasting path for numbers
  fn %to<number> = f64 || u64 || i64 || f32 || u32 || i32 || u16 || i16 || u8 || i8 || bool;
}

/**
 * Types which can be converted to a string
 */
inf Stringifyable {
  // Set a typecasting path for strings
  fn %to<string> = f64 || u64 || i64 || f32 || u32 || i32 || u16 || i16 || u8 || i8 || bool;
}

// ==================== Calculable types ==================== //

/**
 * Calculable types
 * Only for types manipulating instances of themselves for calculations
 */
inf Calculable {
  /**
   * Add this value to another one
   * @param value The value to add to this one
   * @returns The result
   */
  fn %plus (value: _self) : _self;

  /**
   * Substract a value to this one
   * @param value The value to substract to this one
   * @returns The result
   */
  fn %less (value: _self) : _self;

  /**
   * Multiply this value by another one
   * @param value The value to multiply this one by
   * @returns The result
   */
  fn %times (value: _self) : _self;

  /**
   * Divide this value by another one
   * @param value The value to multiply this one by
   * @returns The result
   */
  fn %divide (value: _self) : _self;

  /**
   * Multiply this value by itself a given number of times
   * @param pow The number of times
   * @example self ** 4 == self * self * self * self
   */
  fn %pow (pow: uint) : _self;

  /**
   * Modulo this value by another
   * @param value The value to modulo this one by
   * @returns The result
   */
  fn %modulo (value: _self) : _self;
}

// ==================== Clonable types ==================== //

/**
 * Clonable types
 */
inf Clonable {
  /**
   * Clone the current instance
   * @returns A clone of the current instance
   */
  fn %clone () : _self;
}

// ==================== Serializable types ==================== //

/**
 * Serializable types
 */
inf Serializable {
  /**
   * Serialize the current instance
   * @returns The current instance as a string
   */
  fn %serialize () : string;

  /**
   * Unserialize a string to an instance of the current type
   * @param serialized An instance of the current type, serialized
   * @returns An instance of this type
   */
  static fn %unserialize (serialized: string) throws UnserializationError : _self;
}

// ==================== Comparable types ==================== //

/**
 * Types comparable to a given one
 * @template T The type this one is comparable to
 */
inf ComparableTo<T> {
  /**
   * Check if this instance is equal to another
   * @param another Another instance of this type
   * @returns `true` if this instance is equal to the provided one
   */
  fn %equal (another: T) : bool;

  /**
   * Check if this instance is greater than another
   * @param another Another instance of this type
   * @returns `true` if this instance is greater than the provided one
   */
  fn %greater (another: T) : bool;

  /**
   * Check if this instance is smaller than another
   * @param another Another instance of this type
   * @returns `true` if this instance is smaller than the provided one
   */
  fn %smaller (another: T) : bool;
}

/**
 * Types comparable to themselves
 */
type Comparable = ComparableTo<_>;

// ==================== Randomizable types ==================== //

/**
 * Types able to generate a random value
 */
inf Randomizable {
  /**
   * Generate a random value of this type
   * @returns A random value of this type
   */
  static fn %random () : _self;
}

/**
 * Types able to generate a random value between two bounds
 */
inf RandomizableWithBounds {
  /**
   * This type's minimum value
   */
  static val MINIMUM: _self;

  /**
   * This type's maximum value
   */
  static val MAXIMUM: _self;

  /**
   * Generate a random value of this type between two bounds
   * @param low The lower bound
   * @param up The upper bound
   * @returns A random value of this type
   */
  static fn %random (low: _self, up: _self) : _self;
}

// ==================== Callable types ==================== //

/**
 * Callable types
 * @template T The call method's return type
 */
inf Callable<T> {
  /**
   * Call this instance as a function
   */
  fn %call() : T;
}

/**
 * Callable classes
 * @template T The call method's return type
 */
inf StaticallyCallable<T> {
  /**
   * Call this class as a function
   */
  static fn %call() : T;
}

// ==================== Primitive types ==================== //

/**
 * Primitive type
 */
virtual class Primitive impl BooleanConvertible, IntegerConvertible, FloatConvertible, Numerizable, Stringifyable, Clonable, Serializable, Comparable<_this>, StaticallyCallable<_this> {
  /**
   * Make a NIL @class value
   */
  final pub fn %construct ();

  /**
   * Make a @class from another primitive value
   * @template T A primitive type
   * @param prim Another primitive value
   */
  final pub fn %construct<T ~ Primitive> (prim: T);

  /**
   * Convert this @class to a boolean
   * @returns This @class as a boolean
   */
  abstract pub fn %to<bool> () : bool;

  /**
   * Convert this @class to a 64-bit signed integer
   * @returns This @class as a 64-bit signed integer
   */
  abstract pub fn %to<i64> () : i64;

  /**
   * Convert this @class to a 64-bit unsigned integer
   * @returns This @class as a 64-bit unsigned integer
   */
  abstract pub fn %to<u64> () : u64;

  /**
   * Convert this @class to a 64-bit floating point number
   * @returns This @class as a 64-bit floating point number
   */
  abstract pub fn %to<f64> () : f64;

  /**
   * Convert this @class to a string
   * @returns This @class as a string
   */
  abstract pub fn %to<string> () : string;

  /**
   * Clone this @class
   * @returns A clone of this @class
   */
  abstract pub fn %clone () : _this;

  /**
   * Convert this @class to a string
   * @returns This @class as a string
   */
  abstract pub fn %serialize () : string;

  /**
   * Unserialize a string to a a @class
   * @returns The unserialized string as a a @class
   */
  abstract pub static fn %unserialize (serialized: string) throws UnserializationError : _this;

  /**
   * Check equality with another @class value
   * @param another Another @string value
   * @returns `true` if the two values are equal
   */
  abstract pub fn %equal (another: _this) : bool;

  /**
   * Check if this @class is greater than another
   * @returns `true` if this @class is greater than the other one
   */
  abstract pub fn %greater (another: _self) : _self;

  /**
   * Check if this @class is smaller than another
   * @returns `true` if this @class is smaller than the other one
   */
  abstract pub fn %smaller (another: _self) : _self;

  /**
   * NIL @class value
   */
  abstract pub static val NIL: _self;
}

// ==================== Object types ==================== //

/**
 * Object type
 */
type Object = not Primitive;

// ==================== Voids ==================== //

/**
 * Void type (primitive)
 */
class void extends Primitive impl Randomizable, RandomizableWithBounds {
  super%(...);

  pub static val NIL = null;

  pub fn %to<bool> () : bool => false;

  pub fn %to<i64> () : i64 => 0l;

  pub fn %to<u64> () : u64 => 0ul;

  pub fn %to<f64> () : f64 => 0d;

  pub fn %to<string> () : string => '';

  pub fn %serialize () : string => '';

  pub static fn %unserialize (serialized: string) throws UnserializationError : _self;

  pub fn %equal (another: void) : bool => true;

  pub fn %greater (another: void) : void => false;

  pub fn %smaller (another: void) : void => false;

  pub static fn %call (value: Any) : void => null;

  /**
   * Generate a random boolean
   * @returns A random boolean
   */
  pub static fn %random () : void => null;

  /**
   * The lowest void value
   */
  pub static val MINIMUM = null;

  /**
   * The highest void value
   */
  pub static val MAXIMUM = null;

  /**
   * Generate a random void value between two bounds
   * @param low The lower bound
   * @param up The upper bound
   * @returns A random void between the provided bounds
   */
  pub static fn %random (low: void, up: void) : void => null;
}

// ==================== Booleans ==================== //

/**
 * Boolean type (primitive)
 * @classname(boolean)
 */
class bool extends Primitive impl Randomizable, RandomizableWithBounds {
  super%(...);

  pub static val NIL = false;

  pub fn %to<bool> () : bool => this;

  pub fn %to<i64> () : i64 => this ? 1l : 0l;

  pub fn %to<u64> () : u64 => this ? 1ul : 0ul;

  pub fn %to<f64> () : f64 => this ? 1d : 0d;

  pub fn %to<string> () : string => this ? 'true' : 'false';

  pub fn %serialize () : string => this ? 'true' : 'false';

  pub static fn %unserialize (serialized: string) throws UnserializationError : bool;

  pub fn %equal (another: bool) : bool => this == another;

  pub fn %greater (another: bool) : bool => (this == true && another == false);

  pub fn %smaller (another: bool) : bool => (this == false && another == true);

  pub static fn %call<T ~ BooleanConvertible> (value: T) : bool => <bool> value != false;

  /**
   * Generate a random boolean
   * @returns A random boolean
   */
  pub static fn %random () : bool;

  /**
   * The lowest boolean value
   */
  pub static val MINIMUM = false;

  /**
   * The highest boolean value
   */
  pub static val MAXIMUM = true;

  /**
   * Generate a random boolean value between two bounds
   * @param low The lower bound
   * @param up The upper bound
   * @returns A random boolean between the provided bounds
   */
  pub static fn %random (low: bool, up: bool) : bool;
}

// ==================== Numbers ==================== //

/**
 * Virtual number type (primitive)
 */
virtual class number extends Primitive impl Randomizable, RandomizableWithBounds {
  super%(...);

  pub static val NIL = 0; // i32

  final pub fn %to<bool> () : bool => self != 0;

  final pub fn %to<i64> () : i64;

  final pub fn %to<u64> () : u64;

  final pub fn %to<f64> () : f64;

  final pub fn %to<string> () : string;

  final pub fn %serialize () : string;

  final pub static fn %unserialize (serialized: string) throws UnserializationError : _this;

  final pub fn %equal (another: _this) : bool => self == another;

  final pub fn %greater (another: _this) : _this => self > another;

  final pub fn %smaller (another: _this) : _this => self < another;

  final pub static fn %call<T ~ NumberConvertible> (value: T) : <number> _this;

  final pub static fn %random () : _this;

  final pub static fn %random (low: _this, up: _this) : _this;

  /**
   * Is this number type signed?
   */
  abstract pub static val SIGNED: bool;

  /**
   * Does this number type handle floating-point numbers?
   */
  abstract pub static val HANDLE_FLOATS: bool;

  /**
   * On how many bits this number type fits?
   */
  abstract pub static val SIZE: usize;

  /**
   * Generate a random @class
   * @returns A random @class
   */
  abstract pub static fn %random () : _this;

  /**
   * The lowest @class value
   */
  abstract pub static val MINIMUM: _this;

  /**
   * The highest @class value
   */
  abstract pub static val MAXIMUM: _this;

  /**
   * Generate a random @class value between two bounds
   * @param low The lower bound
   * @param up The upper bound
   * @returns A random @class between the provided bounds
   */
  abstract pub static fn %random (low: _this, up: _this) : _this;
}

/**
 * Virtual integer type (primitive)
 * @classname(virtual integer)
 */
open class vint extends number {
  super%(...);

  final pub static val HANDLE_FLOATS = false;
}

/**
 * Virtual signed integer type (primitive)
 * @classname(virtual signed integer)
 */
open class vsint extends vint {
  super%(...);

  final pub static val SIGNED = true;
}

/**
 * 64-bit signed integer type (primitive)
 */
open class i64 extends vsint {
  super%(...);

  pub static val NIL = 0l;

  pub static val SIZE = 64p;

  pub static val MINIMUM = -9_223_372_036_854_775_808l;

  pub static val MAXIMUM = 9_223_372_036_854_775_807l;
}

/**
 * 32-bit signed integer type (primitive)
 */
open class i32 extends i64 {
  super%(...);

  pub static val NIL = 0;

  pub static val SIZE = 32p;

  pub static val MINIMUM = -2_147_483_648;

  pub static val MAXIMUM = 2_147_483_647;
}

/**
 * 16-bit signed integer type (primitive)
 */
open class i16 extends i32 {
  super%(...);

  pub static val NIL = 0s;

  pub static val SIZE = 16p;

  pub static val MINIMUM = -32_768s;

  pub static val MAXIMUM = 32_767s;
}

/**
 * 8-bit signed integer type (primitive)
 */
class i8 extends i16 {
  super%(...);

  pub static val NIL = 0b;

  pub static val SIZE = 8p;

  pub static val MINIMUM = -128b;

  pub static val MAXIMUM = 127b;
}

/**
 * Virtual unsigned integer type (primitive)
 * @classname(virtual unsigned integer)
 */
open class vuint extends vint {
  super%(...);

  final pub static val SIGNED = false;
}

/**
 * 64-bit unsigned integer type (primitive)
 */
open class u64 extends vuint {
  super%(...);

  pub static val NIL = 0ul;

  pub static val SIZE = 64p;

  pub static val MINIMUM = 0ul;

  pub static val MAXIMUM = 18_446_744_073_709_551_615ul;
}

/**
 * 32-bit unsigned integer type (primitive)
 */
open class u32 extends u64 {
  super%(...);

  pub static val NIL = 0u;

  pub static val SIZE = 32p;

  pub static val MINIMUM = 0u;

  pub static val MAXIMUM = 4_294_967_295u;
}

/**
 * 16-bit unsigned integer type (primitive)
 */
open class u16 extends u32 {
  super%(...);

  pub static val NIL = 0us;

  pub static val SIZE = 16p;

  pub static val MINIMUM = 0us;

  pub static val MAXIMUM = 65_535us;
}

/**
 * 8-bit unsigned integer type (primitive)
 */
class u8 extends u16 {
  super%(...);

  pub static val NIL = 0ub;

  pub static val SIZE = 8p;

  pub static val MINIMUM = 0ub;

  pub static val MAXIMUM = 255ub;
}

/**
 * Architecture-sized unsigned integer type (primitive)
 * Size is equal to the processor's number of bits
 */
class usize extends uint {
  super%(...);

  pub static val NIL = 0p;

  pub static val SIZE = PROC_ARCH_BITS;

  pub static val MINIMUM = 0p;

  pub static val MAXIMUM = 2p ** PROC_ARCH_BITS - 1p;
}

/**
 * Virtual signed floating-point number type (primitive)
 * @classname(virtual signed float)
 */
open class vfloat extends number {
  super%(...);

  final pub static val SIGNED = true;

  final pub static val HANDLE_FLOATS = true;
}

/**
 * 64-bit signed floating-point number type (primitive)
 * @classname
 */
open class f64 extends vfloat {
  super%(...);

  pub static val SIZE = 64p;
}

/**
 * 32-bit signed floating-point number type (primitive)
 * @classname
 */
class f32 extends f64 {
  super%(...);

  pub static val SIZE = 32p;
}

/**
 * 32-bit signed integer type (primitive)
 */
type int = i32;

/**
 * 32-bit unsigned integer type (primitive)
 */
type uint = u32;

// ==================== Strings ==================== //

/**
 * String type (primitive)
 */
class string extends Primitive {
  super%(...);

  pub static val NIL = '';

  /**
   * Check if the string contains a text using the 'in' operator
   * @param lookfor The text to look for
   * @returns `true` if the text was found
   */
  pub fn %contains (lookfor: string) : bool;

  pub fn %to<bool> () : bool => this.length > 0;

  pub fn %to<string> () : string => this;

  /**
   * @example 'Hello \\ "guys"'.%serialize() == "Hello \\\\ \\"guys\\""
   */
  // DEVNOTE: * Add backslashes before each backslash
  //          * Add backslashes before each double quote
  //          * Replace all line breaks by their string equivalent
  //          * Wraps the string between double quotes
  pub fn %serialize () : string;

  pub static fn %unserialize (serialized: string) throws UnserializationError : string;

  // DEVNOTE: * If the strings are different, the strings are not equal
  //          * Compare each character one by one: if any is different, the strings are not equal
  //          * Else, they are equal
  pub fn %equal (another: string) : bool;

  // DEVNOTE: * Compare each character one by one until the end of the shortest string:
  //            -> if this string's character has a greater ASCII code than the other, this string is greater
  //            -> if the other string's character has a greater ASCII code than the other, the other is greater
  //          * Else, if this string is longer than the other one, this string is greater
  //          * Else, this string is not greater than the other (but may still be equal)
  pub fn %greater (another: string) : bool;

  // DEVNOTE: * If this string is equal to the other one, it is not smaller
  //          * If this string is greater than the other one, it is not smaller
  //          * Else, this string is smaller than the other one
  pub fn %smaller (another: string) : bool;

  pub static fn %call (value: Stringifyable) : string => <string> value;

  /**
   * The first character
   */
  pub val firstChar: string;

  /**
   * The last character
   */
  pub val lastChar: string;

  /**
   * The number of characters in the string
   */
  pub val length: u32;

  /**
   * Get the character a given position
   * @param pos The character's position
   * @returns The character
   */
  pub fn charAt (pos: u32) : string;

  /**
   * Get the ASCII code of a character at a given position
   * @param pos The character's position
   * @returns The character's ASCII code
   */
  pub fn charCodeAt (pos: u32) : uint;

  /**
   * Get the code point of a character at a given position
   * @param pos The character's position
   * @returns The character's code point
   */
  pub fn codePointAt (pos: u32) : uint;

  /**
   * Count the times a text appears in this string
   * @param lookfor The text to look for
   * @returns Number of times the given text appears in this string
   */
  pub fn count (lookfor: u32) : uint;

  /**
   * Cut the string
   * @param start The start position
   * @param end The end position
   * @returns The cut string, between the start and end position (both included)
   */
  pub fn cut (start: u32, end: u32) : string;

  /**
   * Check if the string ends with a text
   * @param lookfor The text to look for
   * @returns `true` if the string ends with the given text
   */
  pub fn endsWith (lookfor: string) : bool;

  /**
   * Prefix some characters with a backslash
   * @param chars A list of characters to escape
   * @returns The escaped string
   * @example "'Hello'".escape("'") == "\\'Hello\\'"
   * @samedef
   */
  pub fn escape (chars: Vector<string>) : string;

  /**
   * Get the first word of the string
   * @param sep The word seperator (default: white space)
   * @returns The string's first word
   */
  pub fn firstWord (sep: string = ' ') : string;

  /**
   * Get the index of a string inside this one
   * @param lookfor The string to look for
   * @returns The position of 'lookfor' in the string (null if not found)
   */
  pub fn indexOf (lookfor: string) : u32?;

  /**
   * Get the last index of a string
   * @param lookfor The string to look for
   * @returns The last position of 'lookfor' in the string (null if not found)
   */
  pub fn lastIndexOf (lookfor: string) : u32?;

  /**
   * Get the last word of the string
   * @param sep The word separator (default: white space)
   */
  pub fn lastWord (sep: string = ' ') : string;

  /**
   * Check if the string contains a text
   * @param lookfor The text to look for
   * @returns `true` if the text was found
   */
  pub fn includes (lookfor: string) : bool;

  /**
   * Parse the string as a number (recommended in front of numerical typecasting)
   * @template T The output format (must be a class inheriting from `number` or `number` itself)
   * @param base The input number's base (default: 10 for decimal)
   * @returns The parsed number
   * @example "2".parse() == "2" && "2.8".parse(float) == "2.8"
   */
  pub fn parse<T ~ number = int> (base: T = 10) throws StringParsingError : T;

  /**
   * Repeat the string a given amount of times
   * @param times The amount of times the string must be repeated
   * @returns The string, repeated
   */
  pub fn repeat (times: usize) : string;

  /**
   * Check if the string starts by a text
   * @param lookfor The text to look for
   * @returns `true` if the string starts by the given text
   */
  pub fn startsWith (lookfor: string) : bool;

  /**
   * Split the string into an array
   * @param model The separator
   * @returns An array containing each part of the array as an individual string
   */
  pub fn split (model: string) : string[];

  /**
   * Cut a string (fixed length)
   * @param start The start position
   * @param length The length
   * @returns The string cut from the start position with the given length
   */
  pub fn substr (start: u32, length: u32) : string;

  /**
   * Convert the string to base64
   * @returns This string as a base64 string
   */
  pub fn toBase64 () : string;

  /**
   * Convert the string to a list
   * @returns The string as a list of single characters
   */
  pub fn toList () : List<string>;

  /**
   * Convert the string to an array
   * @returns The string as an array of single characters
   */
  pub fn toArray () : string[];

  /**
   * Get the lowercase version of the string
   * @returns This string, lowercased
   */
  pub fn toLowerCase () : string;

  /**
   * Get the uppercase version of the string
   * @returns This string, uppercased
   */
  pub fn toUpperCase () : string;

  /**
   * Trim spaces at the beginning and the end of the string
   * @returns This string, trimmed
   */
  pub fn trim () : string;

  /**
   * Trim spaces at the beginning of the string
   * @returns This string, trimmed from the left
   */
  pub fn trimLeft () : string;

  /**
   * Trim spaces at the end of the string
   * @returns This string, trimmed for the right
   */
  pub fn trimRight () : string;

  /**
   * Get a word of the string
   * @param pos The word's index (starting from 0)
   * @param sep The word separator (default: white space)
   * @returns The word (in case of error, returns an empty string)
   */
  pub fn word (pos: u32, sep: string = ' ') : string;

  /**
   * Get all string's words (same as splitting with spaces)
   * @param sep Word separator (default: white space)
   * @returns The words
   */
  pub fn words (sep: string = ' ') : string[];

  /**
   * Decode a base64 string
   * @param base64 The base64 string to decode
   * @returns The given base64 string, decoded
   */
  pub static fn fromBase64 (base64: string) : string;

  /**
   * Make a string from a char code
   * @param code The char code to use
   * @returns The string made from the given char code
   */
  pub static fn fromCharCode (code: int) : string;

  /**
   * Make a string from a code point
   * @param code The code point to use
   * @returns The string made from the given code point
   */
  pub static fn fromCodePoint (code: int) : string;
}

// ==================== Descriptor types ==================== //

/**
 * Any type
 */
class Type {}

/**
 * Function type
 */
class Function {}

/**
 * Structure type
 */
class Structure {}

/**
 * Enumeration type
 */
class Enumeration {}

/**
 * Class type
 */
class Class {}

/**
 * Trait type
 */
class Trait {}

/**
 * Interface type
 */
class Interface {}

// ==================== Tuples ==================== //

/**
 * Tuple type
 */
class Tuple {}

// ==================== Dictionaries ==================== //

/**
 * Dictionary type
 * This class is inherited by every dictionary class
 * NOTE: This class is inheritable
 * @template K Type of keys
 * @template V Type of values
 */
virtual dict Dictionary<K, V> {
  /**
   * Get the value associated to an existing key
   * @param key The key to get the value of
   * @returns The value associated to the key
   */
  abstract pub fn %get (key: K) : V;

  /**
   * Associate a value to a key
   * @param key The key to associate a value to
   * @param value The value to associate
   */
  abstract pub fn %set (key: K, value: V);

  /**
   * Delete an existing key (with its value)
   * @param key The key to delete
   */
  abstract pub fn %unset (key: K);

  /**
   * Check if a key exists in this dictionary
   * @param key The key to check the existence of
   * @returns `true` if the key exists
   */
  abstract pub fn %has (key: K) : bool;

  /**
   * Check if a value exists in this dictionary
   * @param value The value to check the existence of
   * @returns `true` if the value exists
   */
  abstract pub fn %contains (key: V) : bool;

  /**
   * Get an iterator on the keys
   * @returns An iterator on the keys
   */
  abstract pub fn %keys () : Iterator<K>;

  /**
   * Get an iterator on the values
   * @returns An iterator on the values
   */
  abstract pub fn %values () : Iterator<V>;
}

// ==================== Maps ==================== //

/**
 * Map type (powered-up dictionary)
 * NOTE: This class is inheritable
 * @classname(map)
 * @template K Type of keys
 * @template V Type of values
 */
open dict Map<K, V> impl Clonable {
  /**
   * The @class's keys
   */
  protected keys: List<K>;

  /**
   * The @class's values
   */
  protected values: List<V>;

  /**
   * Make an empty @class
   */
  pub fn %construct ();

  /**
   * Initialize a @class by getting all the keys and values from another dictionary
   * @template X Type of the other dictionary's keys
   * @template Y Type of the other dictionary's values
   * @param init The dictionary to use for initialization
   */
  pub fn %construct<X ~ K, Y ~ V> (init: Dictionary<X, Y>);

  pub fn %get (key: K) : V;

  pub fn %set (key: K, value: V);

  pub fn %unset (key: K);

  pub fn %has (key: K) : bool;

  pub fn %contains (key: V) : bool;

  pub fn %keys () : Iterator<K>;

  pub fn %values () : Iterator<V>;

  /**
   * Make a new @class with the same keys and values
   * Keys and values will not be cloned themselves
   * @returns A clone of this @class
   */
  pub fn %clone () : _self;

  /**
   * Segment for clonable keys and values
   */
  segment (K ~ Clonable && V ~ Clonable) {
    /**
     * Make a new @class with the same keys and values
     * Keys and values will be cloned
     * @returns A clone of this @class
     */
    pub fn %clone () : _self;
  }

  /**
   * Segment for serializable keys and values
   */
  segment (K ~ Serializable && V ~ Serializable) impl Serializable, Stringifyable {
    /**
     * Stringify this @class, including its keys and values
     * @returns This @class, stringified
     */
    // DEVNOTE: * Stringify each string and value
    //          * Make a JSON object linking the stringified keys to the stringified values
    //          * Return the JSON object, as a string
    pub fn %serialize () : string;

    /**
     * Unserialize a stringified @class
     * @param serialized The @class to unserialize
     * @returns The unserialized @class
     */
    pub static fn %unserialize (serialized: string) throws UnserializationError : _this;

    /**
     * Stringify this @class, including its keys and values
     * @returns This @class, stringified
     */
    // DEVNOTE: Equivalent to %serialize()
    pub fn %to<string> () : string;
  }

  /**
   * Remove all keys and values from this @class
   */
  pub fn clear ();

  /**
   * Associate the same value to every existing key
   * @param value The value to associate
   */
  pub fn fill (value: V);

  /**
   * Filter this @class
   * @param filter The callback to filter the @class with
   * > @param key A @class's key
   * > @param value The value associated to this key
   * > @returns `false` if this key/value pair must be ignored
   * @returns A clone of this @class without the ignored key/value pairs
   * @example ([ 2, 5, -1 ]).filter((i, v) => v > 0) == [ 2, 5 ]
   */
  pub fn filter (filter: fn (key: K, value: T) : bool) : _self;

  /**
   * Filter this @class
   * @param filter The callback to filter the @class with
   * > @param value A @class's value (order is respected)
   * > @returns `false` if this value must be ignored
   * @returns A clone of this @class without the ignored key/value pairs
   * @example ([ 2, 5, -1 ]).filter(i => i > 0) == [ 2, 5 ]
   */
  pub fn filter (filter: fn (value: T) : bool) : _self;

  /**
   * Insert all the keys and values from another dictionary
   * @template X Type of the other dictionary's keys
   * @template Y Type of the other dictionary's values
   * @param merge The dictionary to use for merging
   */
  pub fn merge<X ~ K, Y ~ V> (merge: Dictionary<X, Y>);

  /**
   * Segment for comparable keys and values
   */
  segment (T ~ Comparable) impl Comparable {
    /**
     * Check if this @class is equivalent to another dictionary
     * @param compareTo The @class to compare to this one
     * @returns `true` if this @class and the other dictionary have the same number of keys and if their values are equal
     */
    pub fn %equal (compareTo: Dictionary<K, V>) : bool;

    /**
     * Check if this @class is greater than another dictionary (always `false`)
     * @param compareTo The dictionary to compare this @class
     * @returns `false`
     */
    pub fn %greater (compareTo: Dictionary<K, V>) : bool => false;

    /**
     * Check if this @class is smaller than another dictionary (always `false`)
     * @param compareTo The dictionary to compare this @class
     * @returns `false`
     */
    pub fn %smaller (compareTo: Dictionary<K, V>) : bool => false;
  }

  /**
   * Generate a new @class from this one through a callback
   * The callback is called for each key/value pair
   *  its return value is transparently stored in a new @class
   * @template X Type of keys returned by the callback
   * @template Y Type of values returned by the callback
   * @param generator The generator callback
   * > @param key A @class's key
   * > @param value The value associated to the provided key
   * > @returns A key/pair value to add to the ghost @class
   * @returns The ghost @class generated using the callback
   * @example ({ # 'hello': 'world' }).@class((k, v) => (v, k)) == ({ # 'world': 'hello' })
   */
  pub fn map<X = K, Y = V> (callback: fn (key: K, value: V) : (X, Y)) : Map<X, Y>;

  /**
   * Generate a new @class from this one through a callback
   * Keys are kept ; only values can be generated
   * The callback is called for each key/value pair
   *  its return value is transparently stored in a new @class, linked to the current key
   * @template Y Type of values returned by the callback
   * @param generator The generator callback
   * > @param key A @class's key
   * > @param value The value associated to the provided key
   * > @returns A value to add to the ghost @class
   * @returns The ghost @class generated using the callback (same keys)
   * @example ({ # 'hello': 'world' }).@class((k, v) => 'mom') == ({ # 'hello': 'mom' })
   */
  pub fn map<Y = V> (callback: fn (key: K, value: V) : Y) : Map<K, Y>;

  /**
   * Make a @class from an array of keys and an array of values
   * Keys and values are mapped in the same order they are in the provided vector
   * @template X Type of keys
   * @template Y Type of values
   * @template SIZE Size of the two arrays
   * @param keys The list of keys
   * @param values The list of values
   * @returns The @class generated from the provided lists
   */
  pub static fn fromArrays<X, Y, SIZE: usize> (keys: X[SIZE], values: Y[SIZE]) : Map<X, Y>;
}

// ==================== Map-based types ==================== //

/**
 * Collection of values (map with string keys)
 * @template T Type of values
 * @classname(collection)
 */
type Collection<T> = Map<string, T>;

/**
 * Comparable map
 * @template K Type of keys
 * @template V Type of values
 * @classname(map)
 */
type SortableMap<K ~ Comparable, V ~ Comparable> = Map<K, V>;

/**
 * Map with unique values
 * NOTE: This class is inheritable
 * @template K Type of keys
 * @template V Type of values
 * @classname(set)
 */
open class Set<K, V ~ Comparable> extends Map<K, V> {
  /** @classname */

  super%(...);

  /**
   * Associate a value to a key
   * NOTE: A 'DuplicateValueError' will be thrown if the provided value is already contained
   * NOTE: As all assignment methods like `.merge()` use this overload, they may throw this error too
   * @param key The key to associate a value to
   * @param value The value to associate
   */
  abstract pub fn %set (key: K, value: V);
}

// ==================== Vector type (map-based) ==================== //

/**
 * Vector type
 * @template T Type of values
 * @classname(vector)
 */
virtual dict Vector<T> extends Map<usize, T> {
  super%(...);

  /**
   * This @class's last element
   * NOTE: THis will throw an 'IndexOutOfBoundError' error if the @class is empty
   */
  pub proxy last: T from {
    getter: () => this[@size - 1]
  };

  /**
   * This @class's size
   */
  pub proxy size: usize from {
    getter: @getSize
  };

  /**
   * Get the value associated to an index
   * NOTE: If the provided index is not smaller than this @class's size,
   *        an `IndexOutOfBoundsError` error will be thrown.
   * @param index The index to get the value of
   * @returns The value
   * @condition index < this.size
   */
  pub fn %get (index: usize) : T;

  /**
   * Associate a value to an index
   * NOTE: If the provided index is not smaller than this @class's size,
   *        an `IndexOutOfBoundsError` error will be thrown.
   * @param index The index to associate a value to
   * @param value The value to associate to the index
   * @returns The value
   * @condition index < this.size
   */
  pub fn %set (index: usize, value: T);

  /**
   * Make a vector from a list of values
   * @param values The values to make the @class from
   */
  pub fn %construct (values: ...T);

  /**
   * Concatenate this @class with another vector
   * @param vect The vector to concatenate at the end of this one
   * @param affect If `true`, affects the result to this @class
   * @returns The final @class
   */
  pub fn concat (vect: Vector<T>, affect: bool = false) : _this;

  /**
   * Concatenate this @class with a list of values (does not affect this @class)
   * @param values The values to concatenate at the end of this one
   * @param affect If `true`, affects the result to this @class
   * @returns The final @class
   */
  pub fn concat (values: ...T, affect: bool = false) : _this;

  /**
   * Fill this @class with a single value
   * @param value The value to fill the @class with
   */
  pub fn fill (value: T);

  /**
   * Get this @class's size
   * @returns This @class's size
   */
  pub fn getSize () : usize;

  /**
   * Check if a value is included in the @class
   * @param lookfor The value to look for
   * @returns The value's index ; null if not found
   */
  pub fn indexOf (lookfor: T) : usize?;

  /**
   * List all indexes a value is found at in this @class
   * @param lookfor The value to look for
   * @returns An array of indexes the value was found at
   */
  pub fn indexesOf (lookfor: T) : usize[];

  /**
   * Segment for comparable types
   */
  segment (T ~ Comparable) {
    /**
     * Check if this @class is equivalent to another vector
     * @param compareTo The vector to compare this @class
     * @returns `true` if the vectors have the same indexes and if their values are equall
     */
    pub fn %equal<Vector<T>> (compareTo: Vector<T>) : bool;

    /**
     * Check if this @class is greater than another vector
     * @param compareTo The vector to compare this @class
     * @returns `true` if this @class is greater
     */
     // DEVNOTE: * Compare each value one by one until the end of the shortest vector:
     //            -> if this vector's value is greater than the other, this vector is greater
     //            -> if the other vector's value is greater than the other, the other is greater
     //          * Else, if this vector is longer than the other one, this vector is greater
     //          * Else, this vector is not greater than the other one
    pub fn %greater<Vector<T>> (compareTo: Vector<T>) : bool;

    /**
     * Check if this @class is smaller than another vector
     * @param compareTo The vector to compare this @class
     * @returns `true` if this @class is smaller
     */
    // DEVNOTE: * If this vector is equal to the other one, it is not smaller
    //          * If this vector is greater than the other one, it is not smaller
    //          * Else, this vector is smaller than the other one
    pub fn %smaller<Vector<T>> (compareTo: Vector<T>) : bool;

    /**
     * Check if all values are equal in this vector
     * @returns `true` if all values are equal
     */
    pub fn isUniform () : bool;
  }

  /**
   * Segment for stringifyable types
   */
  segment (T ~ Stringifyable) {
    /**
     * Join all of this @class's values with a string
     * @param str The join string
     * @returns This @class as a string
     */
    pub fn join (str: string) : string;
  }

  /**
   * Get a random element from this @class
   * @returns A random element
   */
  pub fn random () : T;

  /**
   * Shuffle this @class
   * @returns A new @class with all its elements shuffled
   */
  pub fn shuffle () : _self;

  /**
   * Slice this @class
   * NOTE: This function cannot throw an 'IndexOutOfBoundsError' error
   * @param start The start index
   * @param end The end index (if omitted, cuts to the end of this @class)
   * @example ([ 2, 5, 8 ]).slice(1, 2) == [ 5 ]
   * @example ([ 2, 5, 8 ]).slice(1, 8) == [ 5, 8 ]
   * @example ([ 2, 5, 8 ]).slice(1) == [ 5, 8 ]
   * @returns A slice version of this @class
   */
  pub fn slice (start: usize, end: usize) : void;

  /**
   * Reverse this @class
   * @param affect If `true`, affects the result to this @class
   * @returns This @class, reversed
   */
  pub fn reverse (affect: bool = false) : _self;

  /**
   * Create an unknown-sized array from this @class
   * @returns An unknown-sized array with the same indexes and values than this @class
   */
  pub fn toArray () : T[];

  /**
   * Create a list from this @class
   * @returns A list with the same indexes and values than this @class
   */
  pub fn toList () : List<T>;

  /**
   * Segment for self-calculable types
   */
  segment (T ~ Calculable) {
    /**
     * Sum this @class's values (may overflow with too large value)
     * @template T The result type (default: same type than the values)
     * @returns The result
     */
    pub fn sum<X = T> () : i64;
  }

  /**
   * Segment for serializable keys and values
   */
  segment (K ~ Serializable && V ~ Serializable) impl Serializable, Stringifyable {
    /**
     * Stringify this @class, including its values
     * @returns This @class, stringified
     */
    // DEVNOTE: * Stringify each value
    //          * Make a JSON array containing the stringified value, in the right order
    //          * Return the JSON array, as a string
    pub fn %serialize () : string;

    /**
     * Unserialize a stringified @class
     * @param serialized The @class to unserialize
     * @returns The unserialized @class
     */
    pub static fn %unserialize (serialized: string) throws UnserializationError : _self;

    /**
     * Stringify this @class, its values
     * @returns This @class, stringified
     */
    // DEVNOTE: Equivalent to %serialize()
    pub fn %to<string> () : string;
  }
}

// ==================== Vector-based types ==================== //

/**
 * Sortable vector
 * @template T Type of values
 * @classname(vector)
 */
type SortableVector<T ~ Comparable> = Vector<T>;

/**
 * Serializable vector
 * @template T Type of values
 * @classname(vector)
 */
type SerializableVector<T ~ Serializable> = Vector<T>;

// ==================== Array type (vector-based) ==================== //

/**
 * Unknown-sized array
 * @template T Type of values
 * @classname(array)
 */
open dict Array<T> extends Vector<T> {
  super%(...);

  /**
   * The array's size
   */
  pub val length: usize;

  /**
   * Automatically convert this array to a fixed-size array
   * NOTE: An 'ArraySizeMismatchError' will be thrown if this array's size is not equal to the provided template
   * @template SIZE The destination array's size
   */
  #auto
  pub fn %to<T[SIZE], SIZE: usize> () : T[SIZE];

  /**
   * Remove a key and its associated value from the array
   * Always throw an 'ArrayNotDynamicError' error
   * @param key The key to remove
   */
  pub fn %unset (key: usize);

  pub fn getSize () : usize;
}

/**
 * Array
 * @template T Type of values
 * @template SIZE Number of values
 * @classname(array)
 */
dict Array<T, SIZE: usize> extends Vector<T> {
  super%(...);

  pub val length = SIZE;
}

// ==================== Vector type (vector-based) ==================== //

/**
 * List (vector-based)
 * @template T Type of values
 * @classname(list)
 */
dict List<T> extends Vector<T> {
  super%(...);

  /**
   * Get the last element from the list and remove it
   * @returns The ex-last element (null if the list was empty)
   */
  pub fn pop () : T?;

  /**
   * Push an element at the end of the list
   * @param value The value to push
   * @returns The new list's length
   */
  pub fn push (value: T) : usize;

  /**
   * Remove all elements with a given value from the list
   * @param lookfor The value to remove
   */
  pub fn remove (lookfor: T);

  /**
   * Remove the element located at a given index
   * @param index The index of the value to remove
   * @returns The removed element
   */
  pub fn removeAt (index: usize) : T;

  /**
   * Get the first element of the list and remove it
   * @returns The ex-first element (null if the list was empty)
   */
  pub fn shift () : T?;

  /**
   * Remove all elements of the list from an index
   * @param start The index to begin the cut at
   * @returns The cut part
   */
  pub fn splice (start: int) : List<T>;

  /**
   * Remove a part of the list
   * @param start The index to begin the cut at
   * @param length The length of the cut
   * @returns The cut part
   */
  pub fn splice (start: int, length: int) : List<T>;

  /**
   * Push a value at the beginning of the list
   * @param value The value to push at the head
   * @returns The new list's length
   */
  pub fn unshift (value: T) : usize;
}

// ==================== Error types ==================== //

/**
 * Instant of a backtrace
 * Data may be invalid if the program has been mangled
 * Only for debugging purpose, not for production
 */
struct BacktraceInstant {
  /**
   * Filename
   */
  val file: string;

  /**
   * The function's name
   */
  val function: string;

  /**
   * The line number
   */
  val line: usize;

  /**
   * The column number
   */
  val column: usize;
}

/**
 * Error type
 * NOTE: This class is inheritable
 */
open class Error impl Stringifyable {
  /**
   * The error message
   */
  pub val message: string;

  /**
   * The error's backtrace
   */
  pub val backtrace: BacktraceInstant[];

  /**
   * Initialize an error object
   * @param message The error's message
   */
  pub fn %construct (message: string, backtrace: BacktraceInstant[]) {
    @message = message;
    @backtrace = backtrace;
  }

  /**
   * Stringify the error
   * @returns The error, as a string
   */
  pub fn %to<string> () : string;
}

// ==================== Runtime error types ==================== //

/**
 * Runtime error
 */
virtual class RuntimeError extends Error {}

/**
 * Program is out of memory
 */
class OutOfMemory extends RuntimeError {
  pub fn %construct () => @message = 'Program is out of memory';
}

/**
 * Division by zero
 */
class DivisionByZeroError extends RuntimeError {
  pub fn %construct () => @message = 'Cannot divide by zero';
}

/**
 * Unserialization fail
 */
class UnserializationError extends RuntimeError {
  pub fn %construct () => @message = 'Unserialization failed';

  /**
   * Create an instance of UnserializationError
   * @param message The error message
   */
  pub fn %construct (message: string) => @message = message;
}

/**
 * String parsing fail
 */
class StringParsingError extends RuntimeError {
  pub fn %construct () => @message = 'Failed to parse the string as a number';
}

/**
 * Duplicate value in a set
 */
class DuplicateValueError extends RuntimeError {
  pub fn %construct () => @message => 'Cannot assign a duplicate value in a set';
}

/**
 * Access to an out-of-bound index
 */
class IndexOutOfBoundsError extends RuntimeError {
  pub fn %construct () => @message = 'Cannot access an out-of-bound index';
}

/**
 * Array's value removal
 */
class ArrayNotDynamicError extends RuntimeError {
  pub fn %construct () => @message = 'Cannot remove a value from an array';
}

/**
 * Unknown-sized to fixed-size array conversion fail
 */
class ArraySizeMismatchError extends RuntimeError {
  /**
   * Create an array size mismatch error
   * @param fromSize The original array's size
   * @param toSize The destination array's size
   */
  pub fn %construct (fromSize: usize, toSize: usize) => @message = `Cannot convert a ${toSize}-element array to an ${fromSize}-element one`;
}

/**
 * Type constraint's rejection
 */
class TypeConstraintError extends RuntimeError {
  pub fn %construct () => @message = 'Type constraint rejected the assignment';
}

/**
 * Cast fail
 */
class InvalidCastError extends RuntimeError {
  pub fn %construct () => @message = 'Failed to cast to the provided type';
}

/**
 * Union cast fail
 */
class UnionBadTypeError extends RuntimeError {
  pub fn %construct () => @message = 'Failed to cast the union to the given type';
}

/**
 * Future attribute nullable removal fail
 */
class NullFutureAttributeError extends RuntimeError {
  pub fn %construct () => @message = 'Future attribute is still \'null\' after the constructor ends';
}

/**
 * Asynchronous function (promise) rejection
 * @template T The promise's rejection type
 */
class AwaitRejectionError<T> extends RuntimeError {
  /**
   * The rejection data
   */
  #future
  pub val data: T;

  /**
   * Create an 'await' rejection error
   * @param data The promise's rejection data
   */
  pub fn %construct (data: T) => @data = data;
}

// ==================== Promise type ==================== //

/**
 * Promise type
 * @template X Resolution type
 * @template Y Rejection type
 */
open class Promise<X, Y> {
  /**
   * Make a new promise
   * @param core The promise's core function
   * > @param resolve The resolution callback (called in case of success)
   * > > @param data The resolution data
   * > @param reject The rejection callback (called in case of fail)
   * > > @param data The rejection data
   */
  pub fn %construct (core: fn (resolve: fn (data: X), reject: fn (data: Y)));

  /**
   * Set a resolution callback
   * It will be called in case of success
   * @param resolve The resolution callback
   * > @param data The resolution data
   * @returns This promise
   */
  pub fn then (resolve: fn (data: X));

  /**
   * Set a rejection callback
   * It will be called in case of fail
   * @param reject The rejection callback
   * > @param data The rejection data
   * @returns This promise
   */
  pub fn catch (resolve: fn (data: Y));

  /**
   * Set a final callback
   * It will be called after either then or catch have been triggered
   * @param callback The callback function
   * > @param resolution_data The resolution data (may be null)
   * > @param rejection_data The rejection data (may be null)
   * @returns This promise
   */
  pub fn finally (callback: fn (resolution_data: X?, rejection_data: Y?));

  /**
   * Set a final callback
   * It will be called after either then or catch have been triggered
   * @param callback The callback function
   * > @param data Either the resolution or rejection data
   * @returns This promise
   */
  pub fn finally (callback: fn (data: X | Y));
}

/**
 * Error-free promise type
 * @template X Resolution type
 * @template Y Rejection type
 */
class Promise<X> extends Promise<X, void> {
  super%(...);

  /**
   * Make a new promise
   * @param core The promise's core function
   * > @param resolve The resolution callback (called in case of success)
   * > > @param data The resolution data
   */
  pub fn %construct (core: fn (resolve: fn (data: X)));
}

// ==================== Output API ====================

/**
 * The output API
 */
unique class output {
  /**
   * Print something in STDOUT
   * Adds a line break after the message
   * @param message The message to print
   */
  pub fn println (message: string);
}

// ==================== Native flexs ==================== //

/**
 * Print something in STDOUT
 * @param content The content to print
 */
flex println (...content: Stringifyable) {
  for item in content {
    output.println(<string> content);
  }
}

/**
 * Get the type of a value
 * @template T The value's type (auto-filled)
 * @param value Any value
 * @returns The provided value's type
 */
flex typeof<T> (value: T) : #pln<Type> {
  return T;
}

/**
 * Wrap a value inside an entity
 * @template T The value's type (auto-filled)
 * @param value The value to wrap
 * @returns The same value, wrapped in an entity
 */
flex wrap<T> (value: T) : T {
  let _wrapper = value;
  return _wrapper;
}

/**
 * Get the level of a reference
 * @param ref A reference
 * @returns The reference's level
 */
flex levelof (ref: *+ Any) : #pln<usize> {
  return #__std_only_magic_levelof(ref);
}

/**
 * Get the type of a reference's referred
 * @template T The referred's type (auto-filled)
 * @param ref A reference
 * @returns The type of its referred
 */
flex typeof_ref<T> (ref: *+ T) : #pln<Type> {
  return T;
}

/**
 * Get a reference's referred
 * @template T The referred's type (auto-filled)
 * @param ref A reference
 * @returns The provided reference's referred's type
 */
flex depointerize<T> (ref: *+ T) : T {
  return #__std_only_magic_depointerize(ref);
}

/**
 * Iterate through a reference's level
 * @template T The referred's type (auto-filled)
 * @param ref A reference
 * @param callback An iteration callback
 * > @param ref The reference, progressively depointerized
 * > @param level The provided reference's level, decreasing (>= 1)
 * @returns The reference's referred
 */
flex iter_ref<T> (ref: *+ T, callback: flex (ref: *+ T, level: #pln<usize>)) : T {
  return #__std_only_magic_iter_ref(ref, callback);
}

/**
 * Iterate through a tuple
 * @param tuple The tuple to iterate on
 * @param callback An iteration callback
 * > @param index The current index
 * > @param value The value associated to the provided index
 */
flex iter_tuple (tuple: #tuple, callback: flex (index: usize, value: Any) {
  #__std_only_magic_iter_tuple(tuple, callback);
});

// ==================== Native plain constants ==================== //

/**
 * List of NIL values
 */
pln NIL = (null, false, 0b, 0ub, 0s, 0us, 0, 0u, 0l, 0ul, 0f, 0d, '');

/**
 * List of plainable types
 */
pln PLAINABLE = (
  void, // Voids
  bool, // Booleans
  number, // Numbers
  string, // Strings
  Function, // Functions
  Structure, // Structures
  Enumeration, // Enumerations
  Interface, // Interfaces
  Trait, // Traits
  Class, // Classes,
  Type // Types
);

// ==================== Context-dependant constants ==================== //

// NOTE: [WARNING] The values context-dependant constants can take are not fixed for now.
//                 They can considerably evolve before the stable version of the language.

/**
 * Processor architecture
 * @example 'x86' ; 'arm'
 */
val PROC_ARCH: string;

/**
 * Number of bits of the processor (32 or 64 bits only)
 * @example 32p ; 64p
 */
val PROC_ARCH_BITS: usize;

/**
 * Name of the operating system
 * @example 'windows' ; 'linux'
 */
val OS_NAME: string;

/**
 * Platform name
 * NOTE: Equivalent of `uname -a` on Linux
 * @example 'Linux someone-laptop 4.15.0-29-generic #31-Ubuntu SMP Tue Jul 17 15:39:52 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux'
 */
val PLATFORM: string;
