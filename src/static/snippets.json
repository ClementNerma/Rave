{
  "Mutable_Declaration": {
    "prefix": "let",
    "body": [
      "let ${1:name} = ${2:value};"
    ],
    "description": "Mutable declaration"
  },

  "Typed_Mutable_Declaration": {
    "prefix": "let-typed",
    "body": [
      "let ${1:name}: ${2:Type} = ${3:value};"
    ],
    "description": "Typed mutable declaration"
  },

  "Constant_Declaration": {
    "prefix": "val",
    "body": [
      "val ${1:name} = ${2:value};"
    ],
    "description": "Constant declaration"
  },

  "Typed_Constant_Declaration": {
    "prefix": "val-typed",
    "body": [
      "val ${1:name}: ${2:Type} = ${3:value};"
    ],
    "description": "Typed constant declaration"
  },

  "Plain_Constant_Declaration": {
    "prefix": "pln",
    "body": [
      "pln ${1:name} = ${2:'value'};"
    ],
    "description": "Plain constant declaration"
  },

  "Plain_Typed_Constant_Declaration": {
    "prefix": "pln-typed",
    "body": [
      "pln ${1:name}: ${2:string} = ${3:'value'};"
    ],
    "description": "Typed plain constant declaration"
  },

  "Binary_Number": {
    "prefix": "binary",
    "body": [
      "0b${0:110}"
    ],
    "description": "Binary number"
  },

  "Octal_Number": {
    "prefix": "octal",
    "body": [
      "0o${0:475}"
    ],
    "description": "Octal number"
  },

  "Hexadecimal_Number": {
    "prefix": "hexadecimal",
    "body": [
      "0x${1:DEADBEEF}"
    ],
    "description": "Hexadecimal number"
  },

  "Plain_Tuple_Declaration": {
    "prefix": "tuple",
    "body": [
      "pln ${1:name} = (${2:item_1}, ${3:item_2});"
    ],
    "description": "Plain tuple declaration"
  },

  "Structure_Declaration": {
    "prefix": "tuple",
    "body": [
      "/**",
      " * ${2:Description of the structure}",
      " */",
      "struct ${1:Name} {",
      "  ${3:property}: ${4:Type};",
      "}"
    ],
    "description": "Structure_Declaration"
  },

  "Map": {
    "prefix": "map",
    "body": [
      "Map<${1:KeyType}, ${2:ValueType}>"
    ],
    "description": "Map"
  },

  "Collection": {
    "prefix": "collection",
    "body": [
      "Collection<${1:Type}>"
    ],
    "description": "Collection"
  },

  "Inferred_List": {
    "prefix": "list",
    "body": [
      "[ # ${1:'value'} ]"
    ],
    "description": "Inferred list"
  },

  "Inferred_Dictionary": {
    "prefix": "dict",
    "body": [
      "{ # ${1:key}: ${2:'value'} }"
    ],
    "description": "Inferred dictionary"
  },

  "If_Block": {
    "prefix": "if",
    "body": [
      "if (${1:condition}) {",
      "\t$0",
      "}"
    ],
    "description": "If block"
  },

  "If_Else_Block": {
    "prefix": "if-else",
    "body": [
      "if (${1:condition}) {",
      "\t$2",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If + Else block"
  },

  "If_Elsif_Block": {
    "prefix": "if-elsif",
    "body": [
      "if (${1:condition}) {",
      "\t$3",
      "} elsif (${2:condition}) {",
      "\t$4",
      "} else {",
      "\t$0",
      "}"
    ],
    "description": "If + Elsif + Else block"
  },

  "For_Loop": {
    "prefix": "for",
    "body": [
      "for ${1:key} in ${2:0}..${3:10} {",
      "\t$0",
      "}"
    ],
    "description": "For loop"
  },

  "Iterate_Array_Keys": {
    "prefix": "iter-arr-keys",
    "body": [
      "for ${1:key} of ${2:array} {",
      "\t$0",
      "}"
    ],
    "description": "Iterate array keys"
  },

  "Iterate_Array_Values": {
    "prefix": "iter-arr-vals",
    "body": [
      "for ${1:value} in ${2:array} {",
      "\t$0",
      "}"
    ],
    "description": "Iterate array values"
  },

  "Iterate_Dictionary": {
    "prefix": "iter-dict",
    "body": [
      "for ${1:key} -> ${2:value} in ${3:dictionary} {",
      "\t$0",
      "}"
    ],
    "description": "Iterate dictionary"
  },

  "Inline_Generation": {
    "prefix": "inline-generation",
    "body": [
      "(${1:i * i * i} for ${2:i} in ${3:0}..${4:10})"
    ],
    "description": "Inline generation"
  },

  "While_Loop": {
    "prefix": "while",
    "body": [
      "while ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "While loop"
  },

  "Until_Loop": {
    "prefix": "until",
    "body": [
      "until ${1:condition} {",
      "\t$0",
      "}"
    ],
    "description": "Until loop"
  },

  "Do_While_Loop": {
    "prefix": "dowhile",
    "body": [
      "do {",
      "\t$0",
      "} while (${1:condition});"
    ],
    "description": "Do...while loop"
  },

  "Loop_Loop": {
    "prefix": "loop",
    "body": [
      "loop {",
      "\t$0",
      "}"
    ],
    "description": "Loop loop"
  },

  "Match_Block": {
    "prefix": "match",
    "body": [
      "match ${1:subject} {",
      "\t${2:case1} -> ${3:value1};",
      "\t${4:case2} -> ${5:value2};",
      "\tdefault -> ${6:value3}",
      "}"
    ],
    "description": "Match block"
  },

  "Documentation_Block": {
    "prefix": "doc",
    "body": [
      "/**",
      " * $1",
      " */"
    ],
    "description": "Documentation block"
  },

  "Function_Documentation": {
    "prefix": "func-doc",
    "body": [
      "/**",
      " * ${1:What the function does}",
      " * @param ${2:arg} ${3:Description of the argument}",
      " * @returns ${4:Description of the return value}",
      " */"
    ],
    "description": "Function documentation block"
  },

  "Function": {
    "prefix": "func",
    "body": [
      "/**",
      " * ${5:What the function does}",
      " * @param $2 ${6:Description of the argument}",
      " * @returns ${7:Description of the return value}",
      " */",
      "func ${1:name} (${2:arg}: ${3:Type}) : ${4:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Function declaration"
  },

  "Void_Function": {
    "prefix": "void-func",
    "body": [
      "/**",
      " * ${4:What the function does}",
      " * @param $2 ${5:Description of the argument}",
      " */",
      "func ${1:name} (${2:arg}: ${3:Type}) {",
      "\t$0",
      "}"
    ],
    "description": "Void-typed function declaration"
  },

  "Undocumented_Function": {
    "prefix": "nodoc-func",
    "body": [
      "func ${1:name} (${2:arg}: ${3:Type}) : ${4:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Void-typed function declaration"
  },

  "Optional_argument": {
    "prefix": "optional-arg",
    "body": [
      "${1:arg}: ${2:Type} = ${3:defaultValue}"
    ],
    "description": "Optional argument"
  },

  "Nullable_argument": {
    "prefix": "nullable-arg",
    "body": [
      "${1:arg}?: ${2:Type}"
    ],
    "description": "Nullable argument"
  },

  "Lambda": {
    "prefix": "lambda",
    "body": [
      "lambda (${1:arg}: ${2:Type}) : ${3:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Lambda"
  },
  
  "Arrow_Lambda": {
    "prefix": "arrow-lambda",
    "body": [
      "lambda (${1:arg}: ${2:Type}) : ${3:Type} => ${0:value}"
    ],
    "description": "Lambda with arrow syntax"
  },

  "Inferred_Lambda": {
    "prefix": "inferred-lambda",
    "body": [
      "(${1:arg}) => ${0:value}"
    ],
    "description": "Lambda with IST"
  },

  "Inferred_Lambda_Multi": {
    "prefix": "inferred-lambda-multi",
    "body": [
      "(${1:arg}) => {",
      "\t${0:value}",
      "}"
    ],
    "description": "Multi-instructions lambda with IST"
  },

  "Class": {
    "prefix": "class",
    "body": [
      "/**",
      " * ${2:Description of the class}",
      " */",
      "class ${1:ClassName} {",
      "\t$0",
      "}"
    ],
    "description": "Class"
  },

  "Templated_Class": {
    "prefix": "templated-class",
    "body": [
      "/**",
      " * ${3:Description of the class}",
      " * @template ${2} ${4:Description of the template}",
      " */",
      "class ${1:ClassName}<${2:T}> {",
      "\t$0",
      "}"
    ],
    "description": "Templated class"
  },

  "Inheritance": {
    "prefix": "inheritance",
    "body": [
      "inherits ${1:Mother}"
    ],
    "description": "Class inheritance"
  },

  "Implementation": {
    "prefix": "implementation",
    "body": [
      "implements ${1:SomeInterface}"
    ],
    "description": "Class implementation"
  },

  "Attribute": {
    "prefix": "attribute",
    "body": [
      "/**",
      " * ${4:Description of the argument}",
      " */",
      "${1:public} ${2:member}: ${3:Type};"
    ],
    "description": "Class attribute"
  },

  "Readonly-attribute": {
    "prefix": "readonly-attribute",
    "body": [
      "/**",
      " * ${3:Description of the argument}",
      " */",
      "public readonly ${1:member}: ${2:Type};"
    ],
    "description": "Class read-only attribute"
  },

  "Method": {
    "prefix": "method",
    "body": [
      "/**",
      " * ${6:What the function does}",
      " * @param $3 ${7:Description of the argument}",
      " * @returns ${8:Description of the return value}",
      " */",
      "${1:public} func ${2:name} (${3:arg}: ${4:Type}) : ${5:Type} {",
      "\t$0",
      "}"     
    ],
    "description": "Class method"
  },

  "Constructor": {
    "prefix": "constructor",
    "body": [
      "/**",
      " * ${3:What the constructor does}",
      " * @param $2 ${4:Description of the argument}",
      " */",
      "public func %constructor (${1:arg}: ${2:Type}) {",
      "\t$0",
      "}"
    ],
    "description": "Class constructor"
  },

  "Destructor": {
    "prefix": "destructor",
    "body": [
      "/**",
      " * Free this instance",
      " */",
      "public func %free () {",
      "\t$0",
      "}"
    ],
    "description": "Class destructor"
  },

  "Cloning_Overload": {
    "prefix": "cloning",
    "body": [
      "/**",
      " * Clone this instance",
      " * @param $1 An auto-generated clone of this instance",
      " * @returns A respectful clone of this instance",
      " */",
      "public func %clone (${1:clone}) : _self {",
      "\t$0",
      "}"
    ],
    "description": "Class cloning overload"
  },

  "Lazy_Cloning": {
    "prefix": "cloning-lazy",
    "body": [
      "/**",
      " * Lazy cloning overload",
      " */",
      "public pln %lazy_clone = true;"
    ],
    "description": "Class lazy cloning"
  },

  "Serialization_Overload": {
    "prefix": "serializing",
    "body": [
      "/**",
      " * Serialize this instance to a string",
      " * @returns A string representation of this instance",
      " */",
      "public func %serialize () : string {",
      "\t$1",
      "}",
      " ",
      "/**",
      " * Unserialize a string to an instance of this class",
      " * @param $2 A string representation of an instance",
      " * @returns The unserialized string",
      " */",
      "public func %unserialize () : _self {",
      "\t$0",
      "}"
    ],
    "description": "Class serialization overload"
  },

  "Lazy_Serialization": {
    "prefix": "serializing-lazy",
    "body": [
      "/**",
      " * Lazy serialization overload",
      " */",
      "public pln %lazy_serialize = true;",
      " ",
      "/**",
      " * Lazy unserialization overload",
      " */",
      "public pln %lazy_unserialize = true;"
    ],
    "description": "Class lazy serialization"
  },

  "Lazy_Serialization_Fields": {
    "prefix": "serialization-fields",
    "body": [
      "/**",
      " * Fields to serialize (lazy)",
      " */",
      "public pln %lazy_serial_fields = ( '${1:field1}' );"
    ],
    "description": "Fields for class lazy serialization"
  },

  "Inline_Call": {
    "prefix": "inline-call",
    "body": [
      "/**",
      " * ${4:What the overload does}",
      " * @param $1 ${5:Description of the argument}",
      " * @returns ${6:Description of the return value}",
      " */",
      "public func %call (${1:arg}: ${2:Type}) : ${3:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Instances inline call"
  },

  "Inline_Static_Call": {
    "prefix": "inline-static-call",
    "body": [
      "/**",
      " * ${4:What the overload does}",
      " * @param $1 ${5:Description of the argument}",
      " * @returns ${6:Description of the return value}",
      " */",
      "public static func %call (${1:arg}: ${2:Type}) : ${3:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Class inline call"
  },

  "Segments": {
    "prefix": "segment",
    "body": [
      "/**",
      " * ${2:Description of the segment}",
      " */",
      "segment (${1:T inherits Primitive}) {",
      "\t$0",
      "}"
    ],
    "description": "Class segment"
  },

  "Dictionary_Class": {
    "prefix": "dictionary-class",
    "body": [
      "/**",
      " * ${5:Description of the dictionary class}",
      " * @template $2 ${6:Description of the key type}",
      " * @template $3 ${7:Description of the value type}",
      " */",
      "dict ${1:ClassName}<${2:K}, ${3:V}>${4: inherits Map<$2, $3>} {",
      "\t/**",
      "\t * ${9:Get a value from this dictionary}",
      "\t * @param $8 ${10:The key to read}",
      "\t * @returns ${11:The value associated to the key}",
      "\t */",
      "\tpublic func %get (${8:key}: $2) : $3 {",
      "\t\t${12:// Use @keys and @values}",
      "\t}",
      " ",
      "\t/**",
      "\t * ${15:Set a value in this dictionary}",
      "\t * @param $13 ${16:The key to associate a value to}",
      "\t * @param $14 ${17:The value to associate to the key}",
      "\t */",
      "\tpublic func %set (${13:key}: $2, ${14:value}: $3) {",
      "\t\t$0",
      "\t}",
      "}"
    ],
    "description": "Dictionary class"
  },

  "Has_Overload": {
    "prefix":  "has-overload",
    "body": [
      "/**",
      " * ${3:Check if a key exists in the dictionary}",
      " * @param $1 ${4:The key to check}",
      " * @returns ${5:`true` if the key is found}",
      " */",
      "public func %has (${1:key}: ${2:T}) : bool {",
      "\t${0:return $1 in @keys;}",
      "}"
    ],
    "description": "Dictionary class 'has' overload"
  },

  "Unset_Overload": {
    "prefix": "unset-overload",
    "body": [
      "/**",
      " * ${3:Remove a key and its associated value from the dictionary}",
      " * @param $1 ${4:The key to remove with its value}",
      " */",
      "public func %unset (${1:key}: ${2:T}) {",
      "\t$0",
      "}"
    ],
    "description": "Dictionary class 'unset' overload"
  },

  "Iterator_Function": {
    "prefix": "iter",
    "body": [
      "/**",
      " * ${5:What the iterator function does}",
      " * @param $2 ${6:Description of the argument}",
      " * @returns ${7:Description of the generated values}",
      " */",
      "iter func ${1:name} (${2:arg}: ${3:Type}) : ${4:Type} {",
      "\t${0:yield random!($4);}",
      "}"
    ],
    "description": "Iteration function declaration"
  },

  "Throw_Error": {
    "prefix": "throw",
    "body": [
      "throw new ${1:Error}(${0:'An error has occured'});"
    ],
    "description": "Error throwing"
  },

  "Try_Catch": {
    "prefix": "try",
    "body": [
      "try {",
      "\t${1:// Unsafe code}",
      "}",
      " ",
      "catch (${2:e}: ${3:Error}) {",
      "\t${0:println!($2.message);}",
      "}"
    ],
    "description": "Try/catch operation"
  },

  "Try_Catch_Finally": {
    "prefix": "try-clean",
    "body": [
      "try {",
      "\t$1",
      "}",
      " ",
      "catch (${2:e}: ${3:Error}) {",
      "\t${4:println!($2.message);}",
      "}",
      " ",
      "finally {",
      "\t${0:// Cleaning code}",
      "}"
    ],
    "description": "Try/catch/finally operation"
  },

  "Constrained_Type": {
    "prefix": "with",
    "body": [
      "${1:Type} with (${2:/* Condition ('_' is available)})"
    ],
    "description": "Constrained type"
  },

  "Type_Aliasing": {
    "prefix": "type",
    "body": [
      "type ${1:Type} = ${2:Type};"
    ],
    "description": "Type aliasing"
  },

  "Type_Assumption": {
    "prefix": "if-type",
    "body": [
      "if type (${1:entity} ${2:instanceof} ${3:Type}) {",
      "\t$0",
      "}"
    ],
    "description": "Type assumption"
  },

  "Flexible_Function": {
    "prefix": "flex",
    "body": [
      "/**",
      " * ${5:What the flex does}",
      " * @param $2 ${6:Description of the argument}",
      " * @returns ${7:Description of the return value}",
      " */",
      "func ${1:name} (${2:arg}: ${3:Type}) : ${4:Type} {",
      "\t$0",
      "}"
    ],
    "description": "Flexible function"
  },

  "Proxy_Declaration": {
    "prefix": "proxy",
    "body": [
      "/**",
      " * ${3:What the proxy does}",
      " */",
      "proxy ${1:name}: ${2:Type} from {",
      "\tvalue: ${4:new $2()},",
      " ",
      "\tgetter: () : $2 => ${5:@value},",
      " ",
      "\tsetter: (${6:cdt}: $2) => ${7:@value = $6}",
      "};"
    ],
    "description": "Proxy declaration"
  },

  "Flexible_Proxy_Declaration": {
    "prefix": "flex-proxy",
    "body": [
      "/**",
      " * ${3:What the proxy does}",
      " */",
      "proxy ${1:name}: ${2:Type} from {",
      "\tvalue: ${4:new $2()},",
      " ",
      "\tgetter: flex () : $2 => ${5:@value},",
      " ",
      "\tsetter: flex (${6:cdt}: $2) => ${7:@value = $6}",
      "};"
    ],
    "description": "Flexible proxy declaration"
  },

  "Promise": {
    "prefix": "promise",
    "body": [
      "new Promise<${1:ResolutionType}, ${2:RejectionType}>((${3:resolve}, ${4:reject}) => {",
      "\t$0",
      "}"
    ],
    "description": "Promise"
  },

  "Asynchronous_Function": {
    "prefix": "async",
    "body": [
      "/**",
      " * ${6:What the function does}",
      " * @param $2 ${7:Description of the argument}",
      " * @returns ${8:Description of the return value}",
      " */",
      "async func ${1:name} (${2:arg}: ${3:Type}) : (${4:ResolutionType}, ${5:RejectionType}) {",
      "\t$0",
      "}"
    ],
    "description": "Asynchronous function"
  },

  "File_Documentation": {
    "prefix": "file",
    "body": [
      "/**",
      " * @file ${1:Description of the file}",
      " * @author ${2:Author of the file}",
      " * @license ${3:License of the file}",
      " */"
    ],
    "description": "File documentation"
  },

  "Namespace_Declaration": {
    "prefix": "namespace",
    "body": [
      "/**",
      " * ${2:What the namespace does}",
      " */",
      "namespace ${1:Name} {",
      "\t$0",
      "}"
    ],
    "description": "Namespace declaration"
  }
}